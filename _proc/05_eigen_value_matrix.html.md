---
output-file: eigen_value_matrix.html
title: Eigen Value of Matrix

---



<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

Before diving into the function, let's first understand how to calculate eigenvalues.

**Eigenvalues of a matrix** offer significant insight into the matrix's behavior, particularly in the context of linear transformations and systems of linear equations.

### Definition

For a square matrix $A$, eigenvalues are scalars $\lambda$ that satisfy the equation for some non-zero vector $v$ (eigenvector):

$$
Av = \lambda v
$$

### Calculation for a $2 \times 2$ Matrix

The eigenvalues of a $2 \times 2$ matrix $A$, given by:

$$
A = \begin{pmatrix} a & b \\ c & d \end{pmatrix}
$$

are determined by solving the characteristic equation:

$$
\det(A - \lambda I) = 0
$$

This simplifies to a quadratic equation:

$$
\lambda^2 - \text{tr}(A)\lambda + \det(A) = 0
$$

Here, the trace of $A$, denoted as $\text{tr}(A)$, is $a + d$ and the determinant of $A$, denoted as $\det(A)$, is $ad - bc$.
Solving this equation yields the eigenvalues, $\lambda$.

### Significance

Understanding eigenvalues is essential for analyzing the effects of linear transformations represented by the matrix. They are crucial in various applications, including:

- Stability analysis
- Vibration analysis
- Principal Component Analysis (PCA) in machine learning

---

[source](https://github.com/teja00/BuildingBlocks/blob/main/BuildingBlocks/eigen_value_matrix.py#L11){target="_blank" style="float:right; font-size:smaller"}

### calculate_eigenvalues_2by2

>      calculate_eigenvalues_2by2 (matrix:list)

|    | **Type** | **Details** |
| -- | -------- | ----------- |
| matrix | list | matrix of size 2 x 2 |
| **Returns** | **list** | **eigenvalues of the matrix 2 x 1** |


::: {#cell-4 .cell}
``` {.python .cell-code code-fold="show" code-summary="Exported source"}
def calculate_eigenvalues_2by2(matrix: list[list[Union[float,int]]] # matrix of size 2 x 2
						  ) -> list[float]: # eigenvalues of the matrix 2 x 1
    trace = matrix[0][0] + matrix[1][1]
    det = matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0]
    sqrt_value = np.sqrt(trace ** 2 - 4 * det)
    eigen1 = (trace + sqrt_value) / 2
    eigen2 = (trace - sqrt_value) / 2
    return [eigen1, eigen2]
```
:::


## Eigen Value using numpy library for an N x N Matrix

---

[source](https://github.com/teja00/BuildingBlocks/blob/main/BuildingBlocks/eigen_value_matrix.py#L21){target="_blank" style="float:right; font-size:smaller"}

### calculate_eigenvalues

>      calculate_eigenvalues (matrix:list)

|    | **Type** | **Details** |
| -- | -------- | ----------- |
| matrix | list | matrix of size 2 x 2 |
| **Returns** | **list** | **result of size n x 1** |


::: {#cell-7 .cell}
``` {.python .cell-code code-fold="show" code-summary="Exported source"}
def calculate_eigenvalues(matrix: list[list[Union[float,int]]] # matrix of size 2 x 2
						  ) -> list[float]: # result of size n x 1
    np_matrix = np.array(matrix)
    if np_matrix.shape[0] != np_matrix.shape[1]:
        raise ValueError("Eigenvalues are only defined for square matrices.")
    eigenvalues, _ = np.linalg.eig(np_matrix)
    return eigenvalues.tolist()
```
:::


