[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BuildingBlocks",
    "section": "",
    "text": "Install latest from the GitHub repository:\n$ pip install git+https://github.com/teja00/BuildingBlocks.git\nor from conda\n$ conda install -c teja00 BuildingBlocks\nor from pypi\n$ pip install BuildingBlocks",
    "crumbs": [
      "BuildingBlocks"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "BuildingBlocks",
    "section": "",
    "text": "Install latest from the GitHub repository:\n$ pip install git+https://github.com/teja00/BuildingBlocks.git\nor from conda\n$ conda install -c teja00 BuildingBlocks\nor from pypi\n$ pip install BuildingBlocks",
    "crumbs": [
      "BuildingBlocks"
    ]
  },
  {
    "objectID": "index.html#testing",
    "href": "index.html#testing",
    "title": "BuildingBlocks",
    "section": "Testing",
    "text": "Testing\nImport the following to test out the functionalities\nfrom BuildingBlocks.matrix_vector_dot_product import *\nfrom BuildingBlocks.transpose_matrix import *\nfrom BuildingBlocks.reshape_matrix import *\nfrom BuildingBlocks.mean_row_column import *\nfrom BuildingBlocks.matrix_scalar_multiply import *\n\nUnit Test Suite for Matrix dot product Vector\n\nclass TestMatrixDotVector(unittest.TestCase):\n    \n    # Tests for matrix_dot_vector\n    def test_dot_basic(self):\n        self.assertEqual(matrix_dot_vector([[1, 2], [2, 4]], [1, 2]), [5, 10])\n\n    def test_dot_zeros(self):\n        self.assertEqual(matrix_dot_vector([[0, 0], [0, 0]], [1, 2]), [0, 0])\n\n    def test_dot_identity(self):\n        self.assertEqual(matrix_dot_vector([[1, 0], [0, 1]], [7, 3]), [7, 3])\n\n    def test_dot_floats(self):\n        self.assertEqual(matrix_dot_vector([[1.5, -2], [-3, 4.5]], [2, 1]), [1.0, -1.5])\n\n\n\nUnit TestSuite for Transpose Matrix\n\nclass TestMatrixTranspose(unittest.TestCase):\n    # Tests for transpose_matrix\n    def test_transpose_square(self):\n        self.assertEqual(transpose_matrix([[1, 2], [3, 4]]), [[1, 3], [2, 4]])\n\n    def test_transpose_rectangle(self):\n        self.assertEqual(transpose_matrix([[1, 2, 3], [4, 5, 6]]), [[1, 4], [2, 5], [3, 6]])\n\n    def test_transpose_single_row(self):\n        self.assertEqual(transpose_matrix([[1, 2, 3]]), [[1], [2], [3]])\n\n    def test_transpose_single_column(self):\n        self.assertEqual(transpose_matrix([[1], [2], [3]]), [[1, 2, 3]])\n\n\n\nUnit TestSuite for Reshaping Matrix\n\nclass TestMatrixReshape(unittest.TestCase):\n    # Tests for transpose_matrix\n    def test_reshape_basic(self):\n        self.assertEqual(reshape_matrix([[1,2,3,4],[5,6,7,8]], (4, 2)), [[1, 2], [3, 4], [5, 6], [7, 8]])\n\n    def test_transpose_different_size(self):\n        self.assertEqual(reshape_matrix([[1, 2, 3, 4], [5, 6, 7, 8]], (1, 4)), [])\n\n    def test_transpose_same_size(self):\n        self.assertEqual(reshape_matrix([[1,2,3,4],[5,6,7,8]], (2, 4)), [[1, 2, 3, 4], [5, 6, 7, 8]])\n\n\n\nUnit TestSuite for Mean by Row or column\n\nclass TestMeanMatrix(unittest.TestCase):\n    # Tests for transpose_matrix\n    def test_mean_basic(self):\n        self.assertEqual(calculate_matrix_mean([[1, 2, 3], [4, 5, 6], [7, 8, 9]],'column'), [4.0, 5.0, 6.0])\n\n\n\nUnit TestSuite for Matrix Scalar Multiplication\n\nclass TestMatrixMulScalar(unittest.TestCase):\n    # Tests for transpose_matrix\n    def test_mul_scalar_basic(self):\n        self.assertEqual(matrix_scalar_multiply([[1, 2], [3, 4]], 2), [[2, 4], [6, 8]])\n    def test_mul_scalar_negative(self):\n        self.assertEqual(matrix_scalar_multiply([[1, -2], [-3, 4]], -1), [[-1, 2], [3, -4]])\n    def test_mul_scalar_zero(self):\n        self.assertEqual(matrix_scalar_multiply([[1, 2], [3, 4]], 0), [[0, 0], [0, 0]])\n    def test_mul_scalar_float(self):\n        self.assertEqual(matrix_scalar_multiply([[1.5, -2], [-3, 4.5]], 2.0), [[3.0, -4.0], [-6.0, 9.0]])\n\n\n\nUnit TestSuite for Eigen Value Calculation\n\nclass TestEigenValueMatrix2by2(unittest.TestCase):\n    def assertListAlmostEqual(self, list1, list2, places=5):\n        self.assertEqual(len(list1), len(list2))\n        for a, b in zip(sorted(list1), sorted(list2)):\n            self.assertAlmostEqual(a, b, places=places)\n\n    def test_eigen_value_basic(self):\n        self.assertListAlmostEqual(calculate_eigenvalues_2by2([[1, 2], [2, 1]]), [3, -1])\n\n    def test_eigen_value_zero(self):\n        self.assertListAlmostEqual(calculate_eigenvalues_2by2([[0, 0], [0, 0]]), [0, 0])\n\n    def test_eigen_value_identity(self):\n        self.assertListAlmostEqual(calculate_eigenvalues_2by2([[1, 0], [0, 1]]), [1, 1])\n\n    def test_eigen_value_negative(self):\n        self.assertListAlmostEqual(calculate_eigenvalues_2by2([[-1, -2], [-2, -1]]), [-3, 1])\n\n    def test_eigen_value_float(self):  \n        self.assertListAlmostEqual(calculate_eigenvalues_2by2([[1.5, -2], [-3, 4.5]]), [5.872281323269014, 0.1277186767309857])\n\n    def test_eigen_value_complex(self):\n        self.assertListAlmostEqual(calculate_eigenvalues_2by2([[1, 2], [2, 1]]), [3, -1])\n\n\n\nUnit TestSuite Matrix Transformation\n\nclass TestMatrixTransformation(unittest.TestCase):\n    def test_matrix_transformation_test_case_1(self):\n        A = [[1, 2],\n             [3, 4]]\n        T = [[2, 0],\n             [0, 2]]\n        S = [[1, 1],\n             [0, 1]]\n        result = transform_matrix(A, T, S)\n        expected = [[0.5, 1.5],\n                    [1.5, 3.5]]\n        self.assertTrue(\n            np.allclose(result, expected),\n            f\"Expected {expected}, but got {result}\"\n        )\n\n    def test_matrix_transformation_test_case_2(self):\n        A = [[1, 0],\n             [0, 1]]\n        T = [[1, 2],\n             [3, 4]]\n        S = [[2, 0],\n             [0, 2]]\n        result = transform_matrix(A, T, S)\n        expected = [[-4.0, 2.0],\n                    [ 3.0, -1.0]]\n        self.assertTrue(\n            np.allclose(result, expected),\n            f\"Expected {expected}, but got {result}\"\n        )\n\n    def test_matrix_transformation_test_case_3(self):\n        A = [[2, 3],\n             [1, 4]]\n        T = [[3, 0],\n             [0, 3]]\n        S = [[1, 1],\n             [0, 1]]\n        result = transform_matrix(A, T, S)\n        expected = [[0.66666667, 1.66666667],\n                    [0.33333333, 1.66666667]]\n        self.assertTrue(\n            np.allclose(result, expected, atol=1e-6),\n            f\"Expected approx {expected}, but got {result}\"\n        )\n\n\n\nTesting functionality\nTo test the functionality you can use the below code to run the above tests\nunittest.main(argv=[''], verbosity=2, exit=False)\n\n# unittest.main(argv=[''], verbosity=2, exit=False)\n\ntest_eigen_value_basic (__main__.TestEigenValueMatrix2by2) ... ok\ntest_eigen_value_complex (__main__.TestEigenValueMatrix2by2) ... ok\ntest_eigen_value_float (__main__.TestEigenValueMatrix2by2) ... ok\ntest_eigen_value_identity (__main__.TestEigenValueMatrix2by2) ... ok\ntest_eigen_value_negative (__main__.TestEigenValueMatrix2by2) ... ok\ntest_eigen_value_zero (__main__.TestEigenValueMatrix2by2) ... ok\ntest_dot_basic (__main__.TestMatrixDotVector) ... ok\ntest_dot_floats (__main__.TestMatrixDotVector) ... ok\ntest_dot_identity (__main__.TestMatrixDotVector) ... ok\ntest_dot_zeros (__main__.TestMatrixDotVector) ... ok\ntest_mul_scalar_basic (__main__.TestMatrixMulScalar) ... ok\ntest_mul_scalar_float (__main__.TestMatrixMulScalar) ... ok\ntest_mul_scalar_negative (__main__.TestMatrixMulScalar) ... ok\ntest_mul_scalar_zero (__main__.TestMatrixMulScalar) ... ok\ntest_reshape_basic (__main__.TestMatrixReshape) ... ok\ntest_transpose_different_size (__main__.TestMatrixReshape) ... ok\ntest_transpose_same_size (__main__.TestMatrixReshape) ... ok\ntest_matrix_transformation_test_case_1 (__main__.TestMatrixTransformation) ... ok\ntest_matrix_transformation_test_case_2 (__main__.TestMatrixTransformation) ... ok\ntest_matrix_transformation_test_case_3 (__main__.TestMatrixTransformation) ... ok\ntest_transpose_rectangle (__main__.TestMatrixTranspose) ... ok\ntest_transpose_single_column (__main__.TestMatrixTranspose) ... ok\ntest_transpose_single_row (__main__.TestMatrixTranspose) ... ok\ntest_transpose_square (__main__.TestMatrixTranspose) ... ok\ntest_mean_basic (__main__.TestMeanMatrix) ... ok\n\n----------------------------------------------------------------------\nRan 25 tests in 0.009s\n\nOK\n\n\n&lt;unittest.main.TestProgram&gt;",
    "crumbs": [
      "BuildingBlocks"
    ]
  },
  {
    "objectID": "mean_by_row_column.html",
    "href": "mean_by_row_column.html",
    "title": "Mean by Row or Column",
    "section": "",
    "text": "source\n\ncalculate_matrix_mean\n\n calculate_matrix_mean (matrix:list, mode:str)\n\n\n\n\n\nType\nDetails\n\n\n\n\nmatrix\nlist\nMatrix of size m, n\n\n\nmode\nstr\nrepresenting column or row\n\n\nReturns\nlist\nresult of size m, 1 or n, 1\n\n\n\n\n\nExported source\ndef calculate_matrix_mean(  matrix: list[list[Union[int, float]]], # Matrix of size m, n\n                            mode: str # representing column or row\n                          ) -&gt; list[Union[int, float]]: # result of size m, 1 or n, 1\n    matrix = np.array(matrix)\n    \n    if mode == \"row\":\n        means = [np.mean(row) for row in matrix]\n    else:  # assume column mode\n        means = [np.mean(matrix[:, i]) for i in range(matrix.shape[1])]\n    \n    return means",
    "crumbs": [
      "Mean by Row or Column"
    ]
  },
  {
    "objectID": "transpose_of_matrix.html",
    "href": "transpose_of_matrix.html",
    "title": "Transpose of a Matrix",
    "section": "",
    "text": "source\n\ntranspose_matrix\n\n transpose_matrix (a:List[List[Union[int,float]]])\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\na\ntyping.List[typing.List[typing.Union[int, float]]]\nmatrix a of size (n, m)\n\n\nReturns\ntyping.List[typing.List[typing.Union[int, float]]]\nmatrix of size (m, n)\n\n\n\n\n\nExported source\ndef transpose_matrix(a: List[List[Union[int, float]]] # matrix a of size (n, m)\n                     ) -&gt; List[List[Union[int, float]]]: # matrix of size (m, n) \n    n, m = len(a[0]), len(a)  # n = number of columns, m = number of rows\n    return [[a[i][j] for i in range(m)] for j in range(n)]",
    "crumbs": [
      "Transpose of a Matrix"
    ]
  },
  {
    "objectID": "reshape_matrix.html",
    "href": "reshape_matrix.html",
    "title": "Reshape of a Matrix",
    "section": "",
    "text": "the line of code would flatten the matrix of size m by n =&gt; which would have a size m*n\nflat = np.array(a).flatten()\nThe below line of code is a list comprehension, and we are picking blocks of cols  let’s say cols = 10 i.e from  [0, 10]  [10, 20] \nreshaped_matrix = [\n        flat[i * new_shape[1] : (i + 1) * new_shape[1]].tolist()\n        for i in range(new_shape[0])\n    ]\n\nsource\n\n\n\n reshape_matrix (a:List[List[Union[int,float]]], new_shape:tuple)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\na\ntyping.List[typing.List[typing.Union[int, float]]]\nmatrix a of size (m, n) of int or float\n\n\nnew_shape\ntuple\nnew shape tuple to reshape into (a, b)\n\n\nReturns\nlist\noutput matrix of shape (a, b)\n\n\n\n\n\nExported source\ndef reshape_matrix( a: List[List[Union[int, float]]], # matrix a of size (m, n) of int or float\n                    new_shape: tuple[int, int] # new shape tuple to reshape into (a, b)\n                    ) -&gt; list[list[Union[int,float]]]: # output matrix of shape (a, b)\n    flat = np.array(a).flatten()\n\n    # Validate the reshape is possible\n    if len(flat) != new_shape[0] * new_shape[1]:\n        return []\n\n    # Manually reshape using slicing\n    reshaped_matrix = [\n        flat[i * new_shape[1] : (i + 1) * new_shape[1]].tolist()\n        for i in range(new_shape[0])\n    ]\n\n    return reshaped_matrix",
    "crumbs": [
      "Reshape of a Matrix"
    ]
  },
  {
    "objectID": "reshape_matrix.html#algorithm-explanation",
    "href": "reshape_matrix.html#algorithm-explanation",
    "title": "Reshape of a Matrix",
    "section": "",
    "text": "the line of code would flatten the matrix of size m by n =&gt; which would have a size m*n\nflat = np.array(a).flatten()\nThe below line of code is a list comprehension, and we are picking blocks of cols  let’s say cols = 10 i.e from  [0, 10]  [10, 20] \nreshaped_matrix = [\n        flat[i * new_shape[1] : (i + 1) * new_shape[1]].tolist()\n        for i in range(new_shape[0])\n    ]\n\nsource\n\n\n\n reshape_matrix (a:List[List[Union[int,float]]], new_shape:tuple)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\na\ntyping.List[typing.List[typing.Union[int, float]]]\nmatrix a of size (m, n) of int or float\n\n\nnew_shape\ntuple\nnew shape tuple to reshape into (a, b)\n\n\nReturns\nlist\noutput matrix of shape (a, b)\n\n\n\n\n\nExported source\ndef reshape_matrix( a: List[List[Union[int, float]]], # matrix a of size (m, n) of int or float\n                    new_shape: tuple[int, int] # new shape tuple to reshape into (a, b)\n                    ) -&gt; list[list[Union[int,float]]]: # output matrix of shape (a, b)\n    flat = np.array(a).flatten()\n\n    # Validate the reshape is possible\n    if len(flat) != new_shape[0] * new_shape[1]:\n        return []\n\n    # Manually reshape using slicing\n    reshaped_matrix = [\n        flat[i * new_shape[1] : (i + 1) * new_shape[1]].tolist()\n        for i in range(new_shape[0])\n    ]\n\n    return reshaped_matrix",
    "crumbs": [
      "Reshape of a Matrix"
    ]
  },
  {
    "objectID": "matrix_vector_dot_product.html",
    "href": "matrix_vector_dot_product.html",
    "title": "Matrix Vector Dot Product",
    "section": "",
    "text": "source\n\nmatrix_dot_vector\n\n matrix_dot_vector (a:List[List[Union[int,float]]],\n                    b:List[Union[int,float]])\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\na\ntyping.List[typing.List[typing.Union[int, float]]]\nMatrix ’ a’ of size m x n\n\n\nb\ntyping.List[typing.Union[int, float]]\nVector ’ b’ of size n x 1\n\n\nReturns\ntyping.List[typing.Union[int, float]]\nResulting vector of size m x 1:\n\n\n\n\n\nExported source\ndef matrix_dot_vector(a: List[List[Union[int, float]]] # Matrix ' a' of size m x n\n                      , b: List[Union[int, float]] # Vector ' b' of size n x 1\n                      ) -&gt; List[Union[int, float]]: # Resulting vector of size m x 1:\n    if not all(len(row) == len(b) for row in a):\n        return -1\n    result = []\n    for row in a:\n        dot = sum(x * y for x, y in zip(row, b))\n        result.append(dot)\n    return result",
    "crumbs": [
      "Matrix Vector Dot Product"
    ]
  },
  {
    "objectID": "matrix_scalar_multiply.html",
    "href": "matrix_scalar_multiply.html",
    "title": "Matrix Scalar Multiply",
    "section": "",
    "text": "source\n\n\n\n matrix_scalar_multiply (matrix:list, scalar:Union[int,float])\n\n\n\n\n\nType\nDetails\n\n\n\n\nmatrix\nlist\nMatrix of size m,n\n\n\nscalar\ntyping.Union[int, float]\nscalar int or float\n\n\nReturns\nlist\nMatrix of size m, n\n\n\n\n\n\nExported source\ndef matrix_scalar_multiply( matrix: list[list[Union[int,float]]], # Matrix of size m,n\n                            scalar: Union[int,float] # scalar int or float\n                           ) -&gt; list[list[Union[int,float]]]: # Matrix of size m, n\n    matrix = np.array(matrix)\n    result = [(row * scalar).tolist() for row in matrix]\n    return result",
    "crumbs": [
      "Matrix Scalar Multiply"
    ]
  },
  {
    "objectID": "matrix_scalar_multiply.html#rudimentary-way-of-doing-matrix-scalar-multiplication",
    "href": "matrix_scalar_multiply.html#rudimentary-way-of-doing-matrix-scalar-multiplication",
    "title": "Matrix Scalar Multiply",
    "section": "",
    "text": "source\n\n\n\n matrix_scalar_multiply (matrix:list, scalar:Union[int,float])\n\n\n\n\n\nType\nDetails\n\n\n\n\nmatrix\nlist\nMatrix of size m,n\n\n\nscalar\ntyping.Union[int, float]\nscalar int or float\n\n\nReturns\nlist\nMatrix of size m, n\n\n\n\n\n\nExported source\ndef matrix_scalar_multiply( matrix: list[list[Union[int,float]]], # Matrix of size m,n\n                            scalar: Union[int,float] # scalar int or float\n                           ) -&gt; list[list[Union[int,float]]]: # Matrix of size m, n\n    matrix = np.array(matrix)\n    result = [(row * scalar).tolist() for row in matrix]\n    return result",
    "crumbs": [
      "Matrix Scalar Multiply"
    ]
  },
  {
    "objectID": "matrix_scalar_multiply.html#matrix-scalar-multiplication-using-numpy",
    "href": "matrix_scalar_multiply.html#matrix-scalar-multiplication-using-numpy",
    "title": "Matrix Scalar Multiply",
    "section": "Matrix Scalar multiplication using numpy",
    "text": "Matrix Scalar multiplication using numpy\n\nsource\n\nmatrix_scalar_multiply_numpy\n\n matrix_scalar_multiply_numpy (matrix:list, scalar:Union[int,float])\n\n\n\n\n\nType\nDetails\n\n\n\n\nmatrix\nlist\nMatrix of size m,n\n\n\nscalar\ntyping.Union[int, float]\nscalar int or float\n\n\nReturns\nlist\nMatrix of size m, n\n\n\n\n\n\nExported source\ndef matrix_scalar_multiply_numpy( matrix: list[list[Union[int,float]]], # Matrix of size m,n\n                            scalar: Union[int,float] # scalar int or float\n                           ) -&gt; list[list[Union[int,float]]]: # Matrix of size m, n\n    result = np.multiply(matrix, scalar)\n    return result",
    "crumbs": [
      "Matrix Scalar Multiply"
    ]
  },
  {
    "objectID": "matrix_scalar_multiply.html#matrix-scalar-multiplication-using-torch",
    "href": "matrix_scalar_multiply.html#matrix-scalar-multiplication-using-torch",
    "title": "Matrix Scalar Multiply",
    "section": "Matrix Scalar multiplication using torch",
    "text": "Matrix Scalar multiplication using torch\n\nsource\n\nmatrix_scalar_multiply_torch\n\n matrix_scalar_multiply_torch (matrix:list, scalar:Union[int,float])\n\n\n\n\n\nType\nDetails\n\n\n\n\nmatrix\nlist\nMatrix of size m,n\n\n\nscalar\ntyping.Union[int, float]\nscalar int or float\n\n\nReturns\nlist\nMatrix of size m, n\n\n\n\n\n\nExported source\ndef matrix_scalar_multiply_torch( matrix: list[list[Union[int,float]]], # Matrix of size m,n\n                            scalar: Union[int,float] # scalar int or float\n                           ) -&gt; list[list[Union[int,float]]]: # Matrix of size m, n\n    result = torch.mul(matrix, scalar)\n    return result",
    "crumbs": [
      "Matrix Scalar Multiply"
    ]
  },
  {
    "objectID": "eigen_value_matrix.html",
    "href": "eigen_value_matrix.html",
    "title": "Eigen Value of Matrix",
    "section": "",
    "text": "Before diving into the function, let’s first understand how to calculate eigenvalues.\nEigenvalues of a matrix offer significant insight into the matrix’s behavior, particularly in the context of linear transformations and systems of linear equations.",
    "crumbs": [
      "Eigen Value of Matrix"
    ]
  },
  {
    "objectID": "eigen_value_matrix.html#eigen-value-using-numpy-library-for-an-n-x-n-matrix",
    "href": "eigen_value_matrix.html#eigen-value-using-numpy-library-for-an-n-x-n-matrix",
    "title": "Eigen Value of Matrix",
    "section": "Eigen Value using numpy library for an N x N Matrix",
    "text": "Eigen Value using numpy library for an N x N Matrix\n\nsource\n\ncalculate_eigenvalues\n\n calculate_eigenvalues (matrix:list)\n\n\n\n\n\nType\nDetails\n\n\n\n\nmatrix\nlist\nmatrix of size n x n\n\n\nReturns\nlist\nresult of size 1 x n\n\n\n\n\n\nExported source\ndef calculate_eigenvalues(matrix: list[list[Union[float,int]]] # matrix of size n x n\n                          ) -&gt; list[float]: # result of size 1 x n\n    np_matrix = np.array(matrix)\n    if np_matrix.shape[0] != np_matrix.shape[1]:\n        raise ValueError(\"Eigenvalues are only defined for square matrices.\")\n    eigenvalues, _ = np.linalg.eig(np_matrix)\n    return eigenvalues.tolist()",
    "crumbs": [
      "Eigen Value of Matrix"
    ]
  },
  {
    "objectID": "matrix_transformation.html",
    "href": "matrix_transformation.html",
    "title": "Matrix Transformation",
    "section": "",
    "text": "determinant_matrix\n\n determinant_matrix (matrix:numpy.ndarray)\n\nCalculate the determinant of a 2x2 matrix.\n\n\n\n\nType\nDetails\n\n\n\n\nmatrix\nndarray\nmatrix of size (2x2)\n\n\nReturns\nfloat\ndeterminant of the matrix\n\n\n\n\n\nExported source\ndef determinant_matrix(matrix: np.ndarray # matrix of size (2x2)\n                     ) -&gt; float: # determinant of the matrix\n    \"\"\"\n    Calculate the determinant of a 2x2 matrix.\n    \"\"\"\n    if matrix.shape != (2, 2):\n        raise ValueError(\"Matrix must be 2x2.\")\n    \n    a, b, c, d = matrix.flatten()\n    return a * d - b * c\n\n\n\n\n\ncheck_invertibility\n\n check_invertibility (matrix:numpy.ndarray)\n\nCheck if a matrix is invertible.\n\n\n\n\nType\nDetails\n\n\n\n\nmatrix\nndarray\nmatrix of size (2x2)\n\n\nReturns\nbool\nTrue or False\n\n\n\n\n\nExported source\ndef check_invertibility(matrix: np.ndarray # matrix of size (2x2)\n                        ) -&gt; bool: # True or False\n    \"\"\"\n    Check if a matrix is invertible.\n    \"\"\"\n    determinant = determinant_matrix(matrix)\n    return determinant != 0\n\n\n\n\n\ntransform_matrix\n\n transform_matrix (A:list, T:list, S:list)\n\nTransform a matrix A using a transformation matrix T and a scaling matrix S.\n\n\n\n\nType\nDetails\n\n\n\n\nA\nlist\nMatrix of shape (n, n)\n\n\nT\nlist\nMatrix of shape (n , m)\n\n\nS\nlist\nMatrix of shape (n , k)\n\n\nReturns\nlist\nMatrix of shape (m, k)\n\n\n\n\n\nExported source\ndef transform_matrix(A: list[list[Union[int, float]]], # Matrix of shape (n, n)\n                    T: list[list[Union[int, float]]], # Matrix of shape (n , m)\n                    S: list[list[Union[int, float]]]  # Matrix of shape (n , k)\n                    ) -&gt; list[list[Union[int, float]]]: # Matrix of shape (m, k)\n    \"\"\"\n    Transform a matrix A using a transformation matrix T and a scaling matrix S.\n    \"\"\"\n    if not check_invertibility(np.array(T)) and not check_invertibility(np.array(S)):\n        return [-1]\n    T = np.array(T)\n    a, b, c, d = T.flatten()\n    determinant = determinant_matrix(T)\n    inverse_T = [[d/ determinant, -b/ determinant], [-c/ determinant, a/ determinant]]\n    return inverse_T @ np.array(A) @ S",
    "crumbs": [
      "Matrix Transformation"
    ]
  },
  {
    "objectID": "matrix_multiplication.html",
    "href": "matrix_multiplication.html",
    "title": "Matrix Multiplication",
    "section": "",
    "text": "This approach uses the most basic and straightforward method of matrix multiplication, directly applying the definition outlined above.\n\nsource\n\n\n\n matrix_multiply (a:List[List[float]], b:List[List[float]])\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\na\ntyping.List[typing.List[float]]\ninput matrix of size (m, n)\n\n\nb\ntyping.List[typing.List[float]]\ninput matrix of size (n, p)\n\n\nReturns\ntyping.List[typing.List[float]]\noutput matrix of size (m, p)\n\n\n\n\n\nExported source\ndef matrix_multiply(a: List[List[float]], # input matrix of size (m, n)\n                    b: List[List[float]] # input matrix of size (n, p)\n                    ) -&gt; List[List[float]]: # output matrix of size (m, p)\n    a = np.array(a)\n    b = np.array(b)\n    ar, ac = a.shape\n    br, bc = b.shape\n    if ac != br:\n        raise ValueError(\"Incompatible shapes for matrix multiplication\")\n    result = np.zeros((ar, bc))\n    for i in range(ar):\n        for j in range(bc):\n            for k in range(ac): # or br works too\n                result[i][j] += a[i][k] * b[k][j]\n    return result.tolist()",
    "crumbs": [
      "Matrix Multiplication"
    ]
  },
  {
    "objectID": "matrix_multiplication.html#brute-force-methodology",
    "href": "matrix_multiplication.html#brute-force-methodology",
    "title": "Matrix Multiplication",
    "section": "",
    "text": "This approach uses the most basic and straightforward method of matrix multiplication, directly applying the definition outlined above.\n\nsource\n\n\n\n matrix_multiply (a:List[List[float]], b:List[List[float]])\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\na\ntyping.List[typing.List[float]]\ninput matrix of size (m, n)\n\n\nb\ntyping.List[typing.List[float]]\ninput matrix of size (n, p)\n\n\nReturns\ntyping.List[typing.List[float]]\noutput matrix of size (m, p)\n\n\n\n\n\nExported source\ndef matrix_multiply(a: List[List[float]], # input matrix of size (m, n)\n                    b: List[List[float]] # input matrix of size (n, p)\n                    ) -&gt; List[List[float]]: # output matrix of size (m, p)\n    a = np.array(a)\n    b = np.array(b)\n    ar, ac = a.shape\n    br, bc = b.shape\n    if ac != br:\n        raise ValueError(\"Incompatible shapes for matrix multiplication\")\n    result = np.zeros((ar, bc))\n    for i in range(ar):\n        for j in range(bc):\n            for k in range(ac): # or br works too\n                result[i][j] += a[i][k] * b[k][j]\n    return result.tolist()",
    "crumbs": [
      "Matrix Multiplication"
    ]
  },
  {
    "objectID": "matrix_multiplication.html#pytorch-optimization",
    "href": "matrix_multiplication.html#pytorch-optimization",
    "title": "Matrix Multiplication",
    "section": "PyTorch Optimization",
    "text": "PyTorch Optimization\nPyTorch leverages ATen, a high-performance tensor library written in C++. At its core, PyTorch optimizes matrix multiplication by utilizing efficient element-wise operations and parallel computation under the hood. These low-level implementations significantly accelerate the computation.\nLet’s now rewrite the above matrix multiplication using PyTorch’s element-wise operations to take advantage of this optimization.\n\nsource\n\nmatrix_multiply_torch\n\n matrix_multiply_torch (a:List[List[float]], b:List[List[float]])\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\na\ntyping.List[typing.List[float]]\ninput matrix of size (m, n)\n\n\nb\ntyping.List[typing.List[float]]\ninput matrix of size (n, p)\n\n\nReturns\ntyping.List[typing.List[float]]\noutput matrix of size (m, p)\n\n\n\n\n\nExported source\ndef matrix_multiply_torch(a: List[List[float]], # input matrix of size (m, n)\n                          b: List[List[float]] # input matrix of size (n, p)\n                        ) -&gt; List[List[float]]: # output matrix of size (m, p)\n        a = torch.tensor(a)\n        b = torch.tensor(b)\n        ar, ac = a.shape\n        br, bc = b.shape\n        if ac != br:\n            raise ValueError(\"Incompatible shapes for matrix multiplication\")\n        result = torch.zeros((ar, bc))\n        for i in range(ar):\n            for j in range(bc):\n                result[i][j] = torch.sum(a[i, :] * b[:, j])\n        return result",
    "crumbs": [
      "Matrix Multiplication"
    ]
  },
  {
    "objectID": "matrix_multiplication.html#numpy-broadcasting",
    "href": "matrix_multiplication.html#numpy-broadcasting",
    "title": "Matrix Multiplication",
    "section": "Numpy Broadcasting",
    "text": "Numpy Broadcasting\nBroadcasting is a method used by Pytorch (and libraries like NumPy) to automatically expand the shape of smaller arrays so that arithmetic operations (like addition, multiplication) can happen without explicit looping in Python.\n\nStep by Step Breakdown\nLet’s walk through the broadcasting logic:\nc[i] = (a[i,:].unsqueeze(-1) * b).sum(dim=0)\nLet’s assume: - a is of shape (ar, ac) =&gt; e.g., (2, 3) - b is of shape (br, bc) =&gt; e.g., (3, 4) - So ac == br =&gt; matrix multiplication is valid - c will have shape (ar, bc) =&gt; e.g., (2, 4)\n\n1. a[i, :]\nThis picks the ith row of a, which is a 1D tensor of shape (ac,) =&gt; e.g., shape (3,)\n\n\n2. .unsqueeze(-1)\nAdds a new axis at the end (i.e., converts a row vector to a column vector). So now:\na[i,:].unsqueeze(-1) =&gt;  shape becomes (ac, 1) =&gt; e.g., (3, 1)\n\n\n3. a[i,:].unsqueeze(-1) * b\nHere’s where broadcasting happens.\n\na[i,:].unsqueeze(-1) is shape (3, 1)\nb is shape (3, 4)\n\nBroadcasting rule: When dimensions don’t match, PyTorch inserts a 1 in the smaller dimension and stretches it as needed.\nSo effectively:\n(3, 1) * (3, 4)\nbecomes\n(3, 4) * (3, 4)\nEach element of the column vector (from a[i, :]) is multiplied with the corresponding row in b.\n\n\n4. .sum(dim=0)\nThis sums along rows, resulting in a vector of shape (4,).\nSo:\nc[i] = (3, 1) * (3, 4) → (3, 4) → sum over dim=0 → (4,)\nThis becomes the ith row of the result c.\n\n\n\n\nVisual Intuition\nSay:\na[i,:] = [a1, a2, a3]  → shape (3,)\nb = [[b11, b12, b13, b14],\n     [b21, b22, b23, b24],\n     [b31, b32, b33, b34]]  → shape (3, 4)\nThen a[i,:].unsqueeze(-1) = [[a1], [a2], [a3]] → shape (3, 1)\nNow:\na[i,:].unsqueeze(-1) * b =\n[[a1*b11, a1*b12, a1*b13, a1*b14],\n [a2*b21, a2*b22, a2*b23, a2*b24],\n [a3*b31, a3*b32, a3*b33, a3*b34]]  → shape (3, 4)\n\n.sum(dim=0) =\n[ a1*b11 + a2*b21 + a3*b31,\n  a1*b12 + a2*b22 + a3*b32,\n  a1*b13 + a2*b23 + a3*b33,\n  a1*b14 + a2*b24 + a3*b34 ]\nWhich is exactly the dot product of the ith row of a with each column of b.\n\n\n\nSummary\nThis line:\nc[i] = (a[i,:].unsqueeze(-1) * b).sum(dim=0)\nis a clever use of broadcasting to compute one row of matrix multiplication at a time by: - Turning the row of a into a column ((ac,) → (ac, 1)) - Multiplying it with b of shape (ac, bc) to get a broadcasted result - Summing along rows to compute the dot products\nLet me know if you want the same logic visualized with real numbers or debug prints.\n\nsource\n\n\nmatrix_multiply_torch_optimized\n\n matrix_multiply_torch_optimized (a:List[List[float]],\n                                  b:List[List[float]])\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\na\ntyping.List[typing.List[float]]\ninput matrix of size (m, n)\n\n\nb\ntyping.List[typing.List[float]]\ninput matrix of size (n, p)\n\n\nReturns\ntyping.List[typing.List[float]]\noutput matrix of size (m, p)\n\n\n\n\n\nExported source\ndef matrix_multiply_torch_optimized(a: List[List[float]], # input matrix of size (m, n)\n                                    b: List[List[float]] # input matrix of size (n, p)\n                                    ) -&gt; List[List[float]]: # output matrix of size (m, p)\n        a = torch.tensor(a)\n        b = torch.tensor(b)\n        ar, ac = a.shape\n        br, bc = b.shape\n        if ac != br:\n            raise ValueError(\"Incompatible shapes for matrix multiplication\")\n        result = torch.zeros((ar, bc))\n        for i in range(ar):\n              result[i] = (a[i, :].unsqueeze(1) * b).sum(dim = 0)\n              print(result[i], a[i, :].unsqueeze(1), b)\n        return result",
    "crumbs": [
      "Matrix Multiplication"
    ]
  },
  {
    "objectID": "matrix_multiplication.html#using-einsum",
    "href": "matrix_multiplication.html#using-einsum",
    "title": "Matrix Multiplication",
    "section": "Using EINSUM",
    "text": "Using EINSUM\n\nsource\n\nmatrix_multiply_torch_einsum\n\n matrix_multiply_torch_einsum (a:List[List[float]], b:List[List[float]])\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\na\ntyping.List[typing.List[float]]\ninput matrix of size (m, n)\n\n\nb\ntyping.List[typing.List[float]]\ninput matrix of size (n, p)\n\n\nReturns\ntyping.List[typing.List[float]]\noutput matrix of size (m, p)\n\n\n\n\n\nExported source\ndef matrix_multiply_torch_einsum(a: List[List[float]], # input matrix of size (m, n)\n                                    b: List[List[float]] # input matrix of size (n, p)\n                                    ) -&gt; List[List[float]]: # output matrix of size (m, p)\n        a = torch.tensor(a)\n        b = torch.tensor(b)\n        return np.einsum('ij, jk -&gt; ik', a, b).tolist()",
    "crumbs": [
      "Matrix Multiplication"
    ]
  },
  {
    "objectID": "matrix_inverse.html",
    "href": "matrix_inverse.html",
    "title": "Matrix Inverse",
    "section": "",
    "text": "The inverse of a matrix ( A ) is another matrix, often denoted ( A^{-1} ), such that:\n\\[\nAA^{-1} = A^{-1}A = I\n\\]\nwhere ( I ) is the identity matrix. For a 2×2 matrix:\n\\[\nA = \\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}\n\\]\nThe inverse is given by:\n\\[\nA^{-1} = \\frac{1}{\\det(A)} \\begin{pmatrix} d & -b \\\\ -c & a \\end{pmatrix}\n\\]\nprovided that the determinant ( (A) = ad - bc ) is non-zero.\nIf ( (A) = 0 ), the matrix does not have an inverse.\n\n\nImportance\nCalculating the inverse of a matrix is essential in various applications, such as solving systems of linear equations, where the inverse is used to find solutions efficiently.\n\nsource\n\n\ninverse_2x2\n\n inverse_2x2 (matrix:list)\n\n\n\n\n\nType\nDetails\n\n\n\n\nmatrix\nlist\nmatrix to be inverted size (2, 2)\n\n\nReturns\nlist\ninverse of the matrix\n\n\n\n\n\nExported source\ndef inverse_2x2(matrix: list[list[float]] # matrix to be inverted size (2, 2)\n                ) -&gt; list[list[float]]: # inverse of the matrix\n    matrix = np.array(matrix)\n    a, b, c, d  = matrix.flatten()\n    det = a*d - b*c\n    if det == 0:\n        return None\n    adj_matrix = np.array([[d, -b], [-c, a]])\n    inverse = matrix_scalar_multiply_numpy(1/ det, adj_matrix)\n    return inverse",
    "crumbs": [
      "Matrix Inverse"
    ]
  }
]